---
title: "Analysis"
output: html_document
---

```{r import libraries}
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(lme4)
  library(doBy) 
```

```{r Load data}
  #stroop_df and decision_df
  s_df = read.csv('../Data/007_stroop.csv')
  d_df = read.csv('../Data/007_decision.csv')
```

```{r stroop analysis}
  #remove practice
  s_df = s_df[s_df$type %in% c('frequent','infrequent'),]
  #convert logical strings to logical values
  s_df$correct = s_df$correct == 'True'
  s_df$congruent= s_df$congruent == 'True'
  s_df$repeat_stim= s_df$repeat_stim == 'True'
  #spot check that the frequencies are correct
  print(group_by(s_df, type) %>% summarise('incongruent_freq' = mean(congruent)))
  s_df_clean = s_df[s_df$correct == T,]
  #log transform rt's to remove skew, and z-transform across all correct trials
  s_df_clean$rt_logZ = scale(log(s_df_clean$rt))
  stroop_rs = lm(rt_logZ ~ congruent * type, data = s_df_clean)
  summary(stroop_rs)
  #back out of Z/log transform to interpret
  log_rt_mean = mean(log(s_df_clean$rt))
  log_rt_sd = sd(log(s_df_clean$rt))
  invert.logZ = function(x) {exp(x*log_rt_sd+log_rt_mean)}


  IE_freq = stroop_rs$coefficients[2]
  IE_infreq = stroop_rs$coefficients[2] + stroop_rs$coefficients[5]
```

```{r stroop plot}
  RT_summary = group_by(s_df_clean, type, congruent) %>% summarise('meanRT' = mean(rt), 'sdRT' = sd(rt))
  RT_summary = group_by(s_df_clean, type, congruent) %>% summarise('meanRT' = geometric.mean(rt), 'sdRT' = sd(rt))

  ggplot(data = RT_summary, aes(x = congruent, y = meanRT, fill = congruent )) + geom_bar(stat = 'identity') + facet_grid(.~type) +
  geom_linerange(aes(ymin = meanRT-sdRT, ymax = meanRT+sdRT))

  ggplot(data = s_df_clean, aes(x = congruent, y = rt, color = congruent)) + geom_point(position = position_jitter(w = 0.1,h = 0)) + facet_grid(.~type)
```


```{r decision analysis}
  #remove practice trials and only use trials where the subject actually responded
  d_df_clean = d_df[d_df$type == 'task' & d_df$FB!=-1,]
  #refactor dataframe
  cat = sapply(d_df_clean, is.factor) 
  d_df_clean[cat] = lapply(d_df_clean[cat], factor)
  d_df_clean$id = factor(d_df_clean$id)
  d_df_clean$fs_choice = as.factor(d_df_clean$fs_choice)
  d_df_clean$ss_choice = as.factor(d_df_clean$ss_choice)
  d_df_clean$stay = d_df_clean$fs_choice == lag(d_df_clean$fs_choice)
  d_df_clean$stay = factor(d_df_clean$stay, levels = c(FALSE,TRUE), labels = c("Switch","Stay"))
  d_df_clean$lag_transition = lag(d_df_clean$transition)
  d_df_clean$FB = factor(d_df_clean$FB, levels = c(1,0), labels = c("Rewarded","Unrewarded"))
  d_df_clean$lag_FB = lag(d_df_clean$FB)
  #remove first row because we are interested in stayes
  d_df_clean=d_df_clean[-1,]

  decision_rs = glm(stay ~ lag_FB * lag_transition, family = binomial, data = d_df_clean)
  summary(decision_rs)
```

```{r decision plot single subject}
  #rt plots
  ggplot( data = d_df_clean, aes(x=trial, y = ss_RT, color = 'blue')) + geom_point() + geom_point(aes(y = fs_RT, color = 'red'))

  decision_summary = group_by(d_df_clean[-1,], lag_transition, lag_FB) %>% summarise('P_stay' = mean(stay)-1)

  ggplot(data = decision_summary, aes(x = lag_FB, y = P_stay, fill = lag_FB)) + geom_bar(stat = 'identity') + facet_grid(.~lag_transition)
```


```{r Individual analysis and concatenate subjects}
  #load data, extract stroop incongruent effect for both conditions,
  #clean up datasets, and concatenate all subjects
  stroop_files = list.files(path = "../Data", pattern="*stroop.csv", full.names = T)
  decision_files = list.files(path = "../Data", pattern="*decision.csv", full.names = T)
  
  #df for group level statistics
  all_subj_df = data.frame()
  all_subj_stroop = data.frame()
  #record IE and model-based indices for each subject
  individual_stats = data.frame()
  for (i in 1:(length(stroop_files))) {
    s_df = read.csv(stroop_files[i])
    d_df = read.csv(decision_files[i])
    
    #*********************
    #stroop analysis
    #*********************
    #remove practice
    s_df = s_df[s_df$type %in% c('frequent','infrequent'),]
    #convert logical strings to logical values
    s_df$correct = s_df$correct == 'True'
    s_df$congruent= s_df$congruent == 'True'
    s_df$repeat_stim= s_df$repeat_stim == 'True'
    s_df_clean = s_df[s_df$correct == T,]
    #log transform rt's to remove skew, and z-transform across all correct trials
    s_df_clean$rt_logZ = scale(log(s_df_clean$rt))
    stroop_rs = lm(rt_logZ ~ congruent * type + repeat_stim, data = s_df_clean)
    #extract the subject specific IE scores
    IE_freq = stroop_rs$coefficients[2]
    IE_infreq = stroop_rs$coefficients[2] + stroop_rs$coefficients[5]
    #and add them as regressors to the decision dataframe
    d_df$IE_freq = IE_freq
    d_df$IE_infreq = IE_infreq
    #add to all_subj_stroop
    all_subj_stroop = rbind(all_subj_stroop,s_df_clean)
      
    #remove practice trials and only use trials where the subject actually responded
    d_df_clean = d_df[d_df$type == 'task' & d_df$FB!=-1,]
    #refactor dataframe
    cat = sapply(d_df_clean, is.factor) 
    d_df_clean[cat] = lapply(d_df_clean[cat], factor)
    d_df_clean$id = factor(d_df_clean$id)
    d_df_clean$fs_choice = as.factor(d_df_clean$fs_choice)
    d_df_clean$ss_choice = as.factor(d_df_clean$ss_choice)
    d_df_clean$stay = d_df_clean$fs_choice == lag(d_df_clean$fs_choice)
    d_df_clean$stay = factor(d_df_clean$stay, levels = c(FALSE,TRUE), labels = c("Switch","Stay"))
    d_df_clean$lag_transition = lag(d_df_clean$transition)
    d_df_clean$FB = factor(d_df_clean$FB, levels = c(1,0), labels = c("Rewarded","Unrewarded"))
    d_df_clean$lag_FB = lag(d_df_clean$FB)
    #remove first row because we are interested in stayes
    d_df_clean=d_df_clean[-1,]
    #get model-free, model-based index for each subject
    decision_rs = glm(stay ~ lag_FB * lag_transition , family = binomial, data = d_df_clean)
    stats = data.frame('id' = d_df_clean$id[1],
                            'IE_freq' = IE_freq,
                            'IE_infreq' = IE_infreq,
                            'M_free' = coefficients(decision_rs)[2],
                            'M_based' = coefficients(decision_rs)[4])
    individual_stats = rbind(individual_stats, stats)
    
    
    #concatenate for group analysis
    all_subj_df = rbind(all_subj_df,d_df_clean)
    
  }
  
```

```{r Group Analysis}
  #Scale IE scores
  all_subj_df$IE_freq = scale(all_subj_df$IE_freq)
  all_subj_df$IE_infreq = scale(all_subj_df$IE_infreq)
  individual_stats$IE_freq = scale(individual_stats$IE_freq)
  individual_stats$IE_infreq = scale(individual_stats$IE_infreq) 
  #exclude subjects where P(stay)=1 or 0 on any condition (transition*reward)
  decision_subj_summary = group_by(all_subj_df, lag_transition, lag_FB, id) %>% summarise('P_stay' = mean(stay)-1) 
  exclude_subj = decision_subj_summary$id[decision_subj_summary$P_stay==1]
  all_subj_df = all_subj_df[!is.element(all_subj_df$id,exclude_subj),]
  individual_stats = individual_stats[!is.element(individual_stats$id,exclude_subj),]

  #model stay based on FB and stay probability
  decision_rs = glm(stay ~ lag_FB * lag_transition , family = binomial, data = all_subj_df)
  summary(decision_rs)
  
  
  decision_rs_mixed = glmer(stay ~ lag_FB * lag_transition + (lag_FB*lag_transition | id), family = binomial, data = all_subj_df, control=glmerControl(optimizer="bobyqa"))
  summary(decision_rs_mixed)

  decision_rs_infreq = glmer(stay ~ lag_FB * lag_transition * IE_infreq  + (lag_FB*lag_transition | id), family = binomial, data = all_subj_df, control=glmerControl(optimizer="bobyqa"))
  summary(decision_rs_infreq)  

  decision_rs_freq = glmer(stay ~ lag_FB * lag_transition * IE_freq  + (lag_FB*lag_transition | id), family = binomial, data = all_subj_df, control=glmerControl(optimizer="bobyqa"))
  summary(decision_rs_freq)

  #extract model-based index to plot against IE
  individual_stats$r_M_based = coef(decision_rs_mixed)$id[,4]
  individual_stats = gather(individual_stats,"condition","IE",starts_with("IE"))
  #extract P(stay) for transition x reward and confint
  inv_logit = function(x) {exp(x)/(1+exp(x))}
  ci = data.frame(confint(decision_rs_mixed, method = "Wald"))
  ci_by_condition = data.frame(matrix(c(ci['(Intercept)',],
           ci['(Intercept)',] + ci['lag_FBUnrewarded',],
           ci['(Intercept)',] + ci['lag_transitionrare',],
           ci['(Intercept)',] + ci['lag_FBUnrewarded',] + ci['lag_transitionrare',] + ci['lag_FBUnrewarded:lag_transitionrare',]),
           4,byrow=T))
  ci_by_condition$ci25 = as.numeric(ci_by_condition$X1)
  ci_by_condition$ci975 = as.numeric(ci_by_condition$X2)
  ci_by_condition = ci_by_condition[,3:4]
  ci_by_condition=data.frame(lapply(ci_by_condition,inv_logit))
  
  n=length(unique(all_subj_df$id))
  decision_summary = group_by(decision_subj_summary,lag_transition, lag_FB) %>% summarise('P_stay' = mean(P_stay))
  decision_summary$SE = sqrt(decision_summary$P_stay*(1-decision_summary$P_stay)/n)
  decision_summary$P_stay_model =inv_logit(predict(decision_rs_mixed,decision_summary,re.form=~0))
  decision_summary = cbind(decision_summary,ci_by_condition)
                
```


```{r group decision plot }
  #Stroop, for confidence
  RT_summary = group_by(all_subj_stroop, type, congruent) %>% summarise('meanRT' = mean(rt), 'sdRT' = sd(rt))

  ggplot(data = RT_summary, aes(x = congruent, y = meanRT, fill = congruent )) + geom_bar(stat = 'identity') + facet_grid(.~type) +
  geom_linerange(aes(ymin = meanRT-sdRT, ymax = meanRT+sdRT))

  #Decision plots
  ggplot(data = decision_summary, aes(x = lag_transition, y = P_stay_model, fill = lag_transition)) + geom_bar(stat = 'identity') +
  geom_linerange(aes(ymin = ci25, ymax = ci975)) + facet_grid(.~lag_FB) + ylab("Stay Probability") + xlab("") + 
  coord_cartesian(ylim = c(0, 1)) + ggtitle("Model Predictions") + theme_bw()

  ggplot(data = decision_summary, aes(x = lag_transition, y = P_stay, fill = lag_transition)) + geom_bar(stat = 'identity') +
  geom_linerange(aes(ymin = P_stay-SE, ymax = P_stay+SE)) + facet_grid(.~lag_FB) + ylab("Stay Probability") + xlab("") + 
  coord_cartesian(ylim = c(.3, .9)) + ggtitle("Actual Data") + theme_bw()

  ggplot(data = decision_subj_summary, aes(x = lag_transition, y = P_stay, fill = lag_transition)) + geom_bar(stat = 'identity') +
  facet_wrap(~id*lag_FB) + ylab("Stay Probability") + xlab("") + 
  coord_cartesian(ylim = c(0, 1)) + ggtitle("Actual Data by Subject") + theme_bw()

  ggplot(data = individual_stats, aes(x=IE, y = r_M_based, color = condition)) + geom_point() + geom_smooth(method = lm) + facet_grid(.~condition) +xlab("Incongruency Effect (z score") + ylab("Model-based index") + theme_bw()
```


